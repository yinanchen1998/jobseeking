import express from 'express';
import cors from 'cors';
import fetch from 'node-fetch';
import dotenv from 'dotenv';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);
dotenv.config();

const KIMI_API_KEY = process.env.KIMI_API_KEY;
const KIMI_API_URL = 'https://api.moonshot.cn/v1/chat/completions';

// Google æœç´¢å‡½æ•°
async function searchGoogle(query, timeout = 35000) {
  const { searchBing } = await import('./bing-search.js');
  return await searchBing(query, 5);
}


async function fetchWithTimeout(url, options = {}, timeout = 15000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(url, { ...options, signal: controller.signal });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}

function detectSearchType(query) {
  const productPatterns = [/[A-Z][a-z]+[A-Z]/, /[a-z]+[A-Z][a-z]+/, /^(ChatGPT|OpenAI|Claude)/i];
  const needPatterns = [/(ç®€åŽ†|æ±‚èŒ|é¢è¯•|å·¥ä½œ|æ‹›è˜)/, /(å¦‚ä½•|æ€Žä¹ˆ|æŽ¨è)/];
  const isProduct = productPatterns.some(p => p.test(query));
  const isNeed = needPatterns.some(p => p.test(query));
  if (isProduct && !isNeed) return 'product';
  if (isNeed && !isProduct) return 'need';
  return query.length < 20 ? 'product' : 'need';
}

const app = express();
app.use(cors());
app.use(express.json());

app.post('/api/search', async (req, res) => {
  const { query } = req.body;
  if (!query?.trim()) return res.status(400).json({ error: 'æœç´¢è¯ä¸èƒ½ä¸ºç©º' });
  if (!KIMI_API_KEY) return res.status(500).json({ error: 'Kimi API Key æœªé…ç½®' });

  const responseTimeout = setTimeout(() => {
    if (!res.headersSent) res.status(504).json({ error: 'æœç´¢è¶…æ—¶' });
  }, 70000);

  try {
    const searchType = detectSearchType(query);
    console.log(`[Search] ç±»åž‹: ${searchType}, æŸ¥è¯¢: "${query}"`);

    const googlePromise = searchGoogle(query, 35000).catch(() => null);
    
    const prompt = searchType === 'product' 
      ? `æœç´¢äº§å“ï¼š"${query}"ï¼Œè¿”å›žJSONæ•°ç»„ï¼š[{name, chineseName, tagline, description, category, website, source}]`
      : `æœç´¢ï¼š"${query}"ï¼ŒæŽ¨è3-5ä¸ªæ±‚èŒAIå·¥å…·ï¼Œè¿”å›žJSONæ•°ç»„ï¼š[{name, chineseName, tagline, description, category, website, source}]`;

    const kimiPromise = fetchWithTimeout(KIMI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${KIMI_API_KEY}` },
      body: JSON.stringify({ model: 'moonshot-v1-8k', messages: [{ role: 'system', content: 'ä½ æ˜¯æ±‚èŒå·¥å…·æœç´¢ä¸“å®¶ã€‚åªè¿”å›žJSONæ•°ç»„ã€‚' }, { role: 'user', content: prompt }], temperature: 0.3 })
    }, 25000).then(r => r.ok ? r.json() : null).then(d => d?.choices?.[0]?.message?.content || '').catch(() => '');

    const [googleResults, kimiContent] = await Promise.all([googlePromise, kimiPromise]);
    console.log(`[Search] Google: ${googleResults?.length || 0}ä¸ª, Kimi: ${kimiContent ? 'æœ‰' : 'æ— '}`);

    let kimiResults = [];
    if (kimiContent) {
      try { kimiResults = JSON.parse(kimiContent.replace(/```json\s*/g, '').replace(/```\s*$/g, '').trim()); } catch (e) {}
    }

    let finalResults = [];
    if (googleResults?.length) {
      googleResults.forEach(g => finalResults.push({ name: g.title?.split(' - ')[0] || 'Unknown', chineseName: g.title?.split(' - ')[0] || 'Unknown', tagline: g.snippet?.substring(0, 50) + '...', description: g.snippet, category: 'other', website: g.link, source: g.source, linkStatus: { valid: false, checked: false } }));
    }
    kimiResults.forEach(k => { if (!finalResults.some(f => f.website === k.website)) finalResults.push({ ...k, linkStatus: { valid: false, checked: false } }); });

    clearTimeout(responseTimeout);
    res.json({ query, searchType, bingCount: googleResults?.length || 0, kimiCount: kimiResults.length, results: finalResults.slice(0, 5), sources: { google: !!googleResults?.length, kimi: !!kimiResults.length } });
  } catch (error) {
    clearTimeout(responseTimeout);
    res.status(500).json({ error: 'æœç´¢æœåŠ¡å‡ºé”™', message: error.message });
  }
});

app.listen(3001, () => console.log('ðŸš€ åŽç«¯è¿è¡Œåœ¨ http://localhost:3001'));

// äº§å“è°ƒç ” API
const researchTasks = new Map();

// åˆ›å»ºè°ƒç ”ä»»åŠ¡
app.post('/api/research', async (req, res) => {
  const { toolId, toolName } = req.body;
  if (!toolId || !toolName) return res.status(400).json({ error: 'ç¼ºå°‘å‚æ•°' });
  
  const taskId = Date.now().toString();
  
  setTimeout(async () => {
    try {
      const prompt = `ä¸º"${toolName}"ç”Ÿæˆäº§å“è°ƒç ”æŠ¥å‘Šï¼Œè¿”å›žJSONï¼š{summary, details, pros[], cons[], pricing, rating}`;
      const response = await fetch(KIMI_API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${KIMI_API_KEY}` },
        body: JSON.stringify({ model: 'moonshot-v1-8k', messages: [{role: 'user', content: prompt}] })
      });
      const data = await response.json();
      const content = data.choices?.[0]?.message?.content || '';
      
      let report;
      try { report = JSON.parse(content.match(/\{[\s\S]*\}/)[0]); } catch(e) { report = {summary: content, details: content}; }
      
      researchTasks.set(taskId, { status: 'completed', toolId, toolName, report });
    } catch (error) {
      researchTasks.set(taskId, { status: 'failed', error: error.message });
    }
  }, 100);
  
  res.json({ taskId, status: 'pending' });
});

app.get('/api/research/:taskId', (req, res) => {
  const task = researchTasks.get(req.params.taskId);
  if (!task) return res.status(404).json({ error: 'ä»»åŠ¡ä¸å­˜åœ¨' });
  res.json(task);
});

app.delete('/api/research/:toolId', (req, res) => {
  for (const [taskId, task] of researchTasks.entries()) {
    if (task.toolId === req.params.toolId) researchTasks.delete(taskId);
  }
  res.json({ success: true });
});

app.get('/api/research-summary', (req, res) => {
  const summaries = Array.from(researchTasks.values())
    .filter(t => t.status === 'completed')
    .map(t => ({ toolId: t.toolId, toolName: t.toolName, summary: t.report?.summary }));
  res.json({ summaries });
});
